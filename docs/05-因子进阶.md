# 因子进阶 - 复杂因子的编写

现在你已经创建了第一个简单因子，让我们学习如何编写更复杂的因子。就像学会了加法，现在要学乘法和除法一样。

## 🎯 常用函数详解

### 基础计算函数

#### 1. RANK - 排名函数

**作用**：对股票进行排名，就像给考试分数排名一样

```python
# 公式方式
RANK(CLOSE)

# Python 方式
rank = self.RANK(close)
```

**返回值**：-0.5 到 0.5 之间的值
- **0.5**：排名最高（数值最大）
- **-0.5**：排名最低（数值最小）
- **0**：排名中等

**使用场景**：
- 动量因子：按收益率排名
- 价值因子：按估值指标排名

#### 2. RETURNS - 收益率

**作用**：计算股票的收益率，就像计算投资回报率

```python
# 公式方式：计算1日收益率
RETURNS(CLOSE, 1)

# 公式方式：计算20日收益率
RETURNS(CLOSE, 20)

# Python 方式
returns_1d = self.RETURNS(close, period=1)
returns_20d = self.RETURNS(close, period=20)
```

**参数**：
- `period`：计算多少天的收益率，默认是 1

**使用场景**：
- 动量因子：计算过去 N 天的收益率
- 反转因子：计算短期收益率

#### 3. STDDEV - 标准差（波动率）

**作用**：计算波动率，衡量价格波动的程度

```python
# 公式方式：计算20日波动率
STDDEV(RETURNS(CLOSE, 1), 20)

# Python 方式
returns = self.RETURNS(close, period=1)
volatility = self.STDDEV(returns, window=20)
```

**参数**：
- `window`：计算窗口大小，默认是 20

**使用场景**：
- 波动率因子：衡量股票的风险
- 低波动因子：选择波动率低的股票

#### 4. CORRELATION - 相关性

**作用**：计算两个序列的相关性，就像看两个变量是否同步变化

```python
# 公式方式：计算价格和成交量的相关性
CORRELATION(CLOSE, VOLUME, 20)

# Python 方式
corr = self.CORRELATION(close, volume, window=20)
```

**返回值**：-1 到 1 之间
- **1**：完全正相关（同涨同跌）
- **-1**：完全负相关（一个涨一个跌）
- **0**：没有相关性

**使用场景**：
- 量价关系因子：分析价格和成交量的关系

#### 5. DELAY - 延迟

**作用**：获取 N 天前的值，就像看历史记录

```python
# 公式方式：获取20天前的收盘价
DELAY(CLOSE, 20)

# Python 方式
close_20d_ago = self.DELAY(close, period=20)
```

**使用场景**：
- 计算历史收益率
- 计算历史均值

#### 6. IF - 条件判断

**作用**：根据条件选择值，就像 Excel 的 IF 函数

```python
# 公式方式：如果收盘价大于开盘价，返回1，否则返回-1
IF(CLOSE > OPEN, 1, -1)

# Python 方式
signal = self.IF(close > open, 1, -1)
```

**使用场景**：
- 趋势判断：上涨时买入，下跌时卖出
- 条件筛选：满足条件才计算

### 时间序列函数

#### 1. SUM - 求和

**作用**：计算过去 N 天的总和

```python
# 公式方式：计算20日成交量总和
SUM(VOLUME, 20)

# Python 方式
volume_sum = self.SUM(volume, window=20)
```

#### 2. TS_MEAN - 移动平均

**作用**：计算过去 N 天的平均值

```python
# 公式方式：计算20日移动平均
TS_MEAN(CLOSE, 20)

# Python 方式
ma_20 = self.TS_MEAN(close, window=20)
```

#### 3. TS_MAX / TS_MIN - 最大值/最小值

**作用**：计算过去 N 天的最大值/最小值

```python
# 公式方式
TS_MAX(CLOSE, 20)  # 20日最高价
TS_MIN(CLOSE, 20)  # 20日最低价

# Python 方式
high_20d = self.TS_MAX(close, window=20)
low_20d = self.TS_MIN(close, window=20)
```

### 技术指标函数

系统提供了丰富的技术指标，如 MACD、RSI、KDJ 等。详细列表请查看[函数和算子支持情况](https://www.pandaai.online/community/article/72)。

## 🎨 多因子组合

### 示例 1：动量 + 波动率

```python
class MomentumVolatilityFactor(Factor):
    """动量波动率组合因子
    
    结合动量和波动率，选择涨得快且波动小的股票。
    """
    
    def calculate(self, factors):
        close = factors['close']
        
        # 计算20日收益率（动量）
        returns = self.RETURNS(close, period=20)
        
        # 计算20日波动率
        daily_returns = self.RETURNS(close, period=1)
        volatility = self.STDDEV(daily_returns, window=20)
        
        # 动量排名
        momentum_rank = self.RANK(returns)
        
        # 波动率排名（波动率越小越好，所以取负值）
        vol_rank = self.RANK(-volatility)
        
        # 组合：动量高且波动率低
        result = momentum_rank * 0.7 + vol_rank * 0.3
        
        return result
```

### 示例 2：量价关系因子

```python
class VolumePriceFactor(Factor):
    """量价关系因子
    
    分析价格和成交量的关系，寻找量价配合的股票。
    """
    
    def calculate(self, factors):
        close = factors['close']
        volume = factors['volume']
        
        # 计算价格变化
        price_change = close / self.DELAY(close, 1) - 1
        
        # 计算成交量变化
        volume_change = volume / self.DELAY(volume, 1) - 1
        
        # 计算相关性
        corr = self.CORRELATION(price_change, volume_change, window=20)
        
        # 价格和成交量都上涨
        price_up = self.IF(price_change > 0, 1, 0)
        volume_up = self.IF(volume_change > 0, 1, 0)
        
        # 量价配合信号
        signal = price_up * volume_up * corr
        
        return self.RANK(signal)
```

## 🔧 性能优化技巧

### 1. 避免重复计算

**不好的做法**：
```python
def calculate(self, factors):
    returns_1 = self.RETURNS(close, 1)
    returns_2 = self.RETURNS(close, 1)  # 重复计算！
    volatility = self.STDDEV(returns_1, 20)
    volatility2 = self.STDDEV(returns_2, 20)  # 重复计算！
```

**好的做法**：
```python
def calculate(self, factors):
    returns = self.RETURNS(close, 1)  # 只计算一次
    volatility = self.STDDEV(returns, 20)  # 复用结果
```

### 2. 使用向量化操作

**不好的做法**：
```python
# 使用循环（慢）
result = []
for i in range(len(close)):
    result.append(close[i] * 2)
```

**好的做法**：
```python
# 使用向量化（快）
result = close * 2
```

### 3. 合理使用缓存

如果因子计算很复杂，可以考虑使用持久化功能，将计算结果保存到数据库。

## 💡 最佳实践

1. **代码清晰**：使用有意义的变量名，添加注释
2. **模块化**：将复杂逻辑拆分成多个步骤
3. **测试验证**：创建后先在小范围数据上测试
4. **文档记录**：记录因子的设计思路和参数含义

## 🎓 更多资源

- [函数和算子支持情况](https://www.pandaai.online/community/article/72) - 查看所有可用函数
- [数据分析](./06-数据分析.md) - 学习如何分析因子效果
- [最佳实践](./08-最佳实践.md) - 更多经验和技巧

---

**继续学习**：[数据分析](./06-数据分析.md) - 学会分析你的因子效果 🚀

